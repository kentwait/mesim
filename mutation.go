package mesim

import (
	"math/rand"
	"mesim/sampler"
)

// MutateChar mutates the character into another based on a given rate
// matrix. The passed character is expected to correspond to the row index
// of the given rate matrix.
func MutateChar(charPtr *int, rateMatrix [][]float64) {
	*charPtr = sampler.MultinomialWhere(1, rateMatrix[*charPtr], 1)[0]
}

// MutateSeqExplicitly mutates characters in the sequence probabilistically
// based on the given transition rate matrix. This function checks each
// character in the sequence and uses the given rate matrix to determine
// whether the character changes into another or stays the same.
func MutateSeqExplicitly(seqArrayPtr *[]int, rateMatrix [][]float64) {
	for i, char := range *seqArrayPtr {
		(*seqArrayPtr)[i] = sampler.MultinomialWhere(1, rateMatrix[char], 1)[0]
	}
}

// MutateSeqFast mutates characters in the sequence probabilistically based on
// a given mutation rate and a transition rate matrix. The forward diagonal of
// the transition rate matrix should have zero values.
//
// This function first generates the coordinates where mutations will occur
// by sampling a Poisson distribution where the average number of events lambda
// is given by the mutation rate. Only the subset of characters that match the
// generated coordinates will be mutated. In this case, transition to another
// character is guaranteed.
func MutateSeqFast(seqArrayPtr *[]int, mu float64, zeroedRateMatrix [][]float64) {
	// Returns three arrays of equal lengths.
	// array[0] is always 0, array[1] is column coords, and
	// array[2] is number of hits
	mutCoords := sampler.PoissonMutCoords(mu, len(*seqArrayPtr), 1)
	var tmpArray []int
	if len(mutCoords[2]) > 0 {
		for _, yPos := range mutCoords[1] {
			tmpArray = append(tmpArray, (*seqArrayPtr)[yPos])
		}
		MutateSeqExplicitly(&tmpArray, zeroedRateMatrix)
		for i, xPos := range mutCoords[0] {
			(*seqArrayPtr)[xPos] = tmpArray[i]
		}
	}

}

// MutateSeqSpace mutates characters in the given sequence space
// probabilistically based on a given mutation rate and a transition rate
// matrix. The forward diagonal of the transition rate matrix should have
// zero values.
//
// First the function generates the number of mutation hits per sequence by
// sampling a Poisson distribution where the average number of events lambda
// is given by the mutation rate times the number of sites per sequence.
// The position of the hits in a sequence are randomly generated by
// permuting the sites such that we sample the without replacement.
// Then characters at the randomly sampled positions are mutated based on
// the given transition rate matrix.
func MutateSeqSpace(seqSpacePtr *[][]int, mu float64, rateMatrix [][]float64) {
	if len(*seqSpacePtr) == 0 {
		panic("Length of seqSpace must be greater than zero")
	} else {
		if len((*seqSpacePtr)[0]) == 0 {
			panic("Length of rows in seqSpace must be greater than zero")
		}
	}
	popSize := len(*seqSpacePtr)
	numSites := len((*seqSpacePtr)[0])
	muPerSeq := mu * float64(numSites)

	// Returns three arrays of equal lengths.
	// array[0] is always 0, array[1] is column coords, and
	// array[2] is number of hits
	hitsPerSeq := sampler.PoissonMutCoords(muPerSeq, popSize, 1)

	var permSites []int
	var seqIdx int
	for i, hits := range hitsPerSeq[2] {
		permSites = rand.Perm(numSites)
		seqIdx = hitsPerSeq[0][i]
		for _, siteIdx := range permSites[:hits] {
			MutateChar(&(*seqSpacePtr)[seqIdx][siteIdx], rateMatrix)
		}
	}
}
